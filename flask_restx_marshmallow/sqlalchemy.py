"""
Description: patched salalchemy of flask_restx_marshmallow
version: 0.1.0
Author: 1746104160
Date: 2023-06-02 12:56:56
LastEditors: 1746104160 shaojiahong2001@outlook.com
LastEditTime: 2023-06-16 14:16:40
FilePath: /flask_restx_marshmallow/flask_restx_marshmallow/sqlalchemy.py
"""
from typing import Optional
from weakref import WeakKeyDictionary

import sqlalchemy as sa
from flask import Flask
from flask_sqlalchemy import SQLAlchemy as original
from flask_sqlalchemy.model import Model as originModel
from flask_sqlalchemy.session import Session
from flask_sqlalchemy.table import _Table as Table
from sqlalchemy.orm import DeclarativeMeta, Query, scoped_session
from typing_extensions import override


class Model(originModel):
    """help type hint for query"""

    query: Query


class SQLAlchemy(original):
    """patched flask_sqlalchemy"""

    # pylint: disable=super-init-not-called
    @override
    def __init__(
        self,
        app: Flask | None = None,
        *,
        metadata: sa.MetaData | None = None,
        session_options: Optional[dict] = None,
        query_class: type[Query] = Query,
        model_class: type[Model] | type[DeclarativeMeta] = Model,
        engine_options: Optional[dict] = None,
        add_models_to_shell: bool = True
    ) -> None:
        if session_options is None:
            session_options = {}

        self.Query: type[Query] = query_class
        """The default query class used by ``Model.query`` and ``lazy="dynamic"``
        relationships.

        .. warning::
            The query interface is considered legacy in SQLAlchemy.

        Customize this by passing the ``query_class`` parameter to the extension.
        """

        self.session: scoped_session[Session] = self._make_scoped_session(
            session_options
        )
        """A :class:`sqlalchemy.orm.scoping.scoped_session` that creates instances of
        :class:`.Session` scoped to the current Flask application context. The session
        will be removed, returning the engine connection to the pool, when the
        application context exits.

        Customize this by passing ``session_options`` to the extension.

        This requires that a Flask application context is active.

        .. versionchanged:: 3.0
            The session is scoped to the current app context.
        """

        self.metadatas: dict[str | None, sa.MetaData] = {}
        """Map of bind keys to :class:`sqlalchemy.schema.MetaData` instances. The
        ``None`` key refers to the default metadata, and is available as
        :attr:`metadata`.

        Customize the default metadata by passing the ``metadata`` parameter to the
        extension. This can be used to set a naming convention. When metadata for
        another bind key is created, it copies the default's naming convention.

        .. versionadded:: 3.0
        """

        if metadata is not None:
            metadata.info["bind_key"] = None
            self.metadatas[None] = metadata

        self.Table: type[Table] = self._make_table_class()
        """A :class:`sqlalchemy.schema.Table` class that chooses a metadata
        automatically.

        Unlike the base ``Table``, the ``metadata`` argument is not required. If it is
        not given, it is selected based on the ``bind_key`` argument.

        :param bind_key: Used to select a different metadata.
        :param args: Arguments passed to the base class. These are typically the table's
            name, columns, and constraints.
        :param kwargs: Arguments passed to the base class.

        .. versionchanged:: 3.0
            This is a subclass of SQLAlchemy's ``Table`` rather than a function.
        """

        self.Model: type[Model] = self._make_declarative_base(model_class)
        """A SQLAlchemy declarative model class. Subclass this to define database
        models.

        If a model does not set ``__tablename__``, it will be generated by converting
        the class name from ``CamelCase`` to ``snake_case``. It will not be generated
        if the model looks like it uses single-table inheritance.

        If a model or parent class sets ``__bind_key__``, it will use that metadata and
        database engine. Otherwise, it will use the default :attr:`metadata` and
        :attr:`engine`. This is ignored if the model sets ``metadata`` or ``__table__``.

        Customize this by subclassing :class:`.Model` and passing the ``model_class``
        parameter to the extension. A fully created declarative model class can be
        passed as well, to use a custom metaclass.
        """

        if engine_options is None:
            engine_options = {}

        self._engine_options: dict = engine_options
        self._app_engines: WeakKeyDictionary[
            Flask, dict[str | None, sa.engine.Engine]
        ] = WeakKeyDictionary()
        self._add_models_to_shell: bool = add_models_to_shell

        if app is not None:
            self.init_app(app)

    @override
    def _make_scoped_session(self, options: dict) -> scoped_session[Session]:
        return super()._make_scoped_session(options)

    @override
    def _make_declarative_base(self, model: Model | DeclarativeMeta) -> Model:
        return super()._make_declarative_base(model)

    @override
    def _make_table_class(self) -> Table:
        return super()._make_table_class()
